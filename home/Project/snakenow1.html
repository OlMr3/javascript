<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Змейка на Canvas</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: #222;
    color: #eee;
    font-family: Arial, sans-serif;
  }
  #game-container {
    position: relative;
    width: 90vmin;
    height: 90vmin;
    max-width: 600px;
    max-height: 600px;
    border: 2px solid #eee;
    background-color: #111;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    background-color: #111;
  }
  #ui {
    margin-top: 10px;
    width: 90vmin;
    max-width: 600px;
    display:flex; justify-content: space-between; align-items:center;
  }
  #score, #lives {
    font-size: 1.2em;
  }
  #start-btn {
    padding: .5em 1em;
    font-size:1.1em;
    cursor:pointer;
    background-color:#444; border:none; color:#eee; border-radius:4px;
    transition: background-color .3s ease;
  }
  #start-btn:hover:not(:disabled) {
    background-color:#666;
  }
  
  #game-over {
    position:absolute;
    top:50%; left:50%;
    transform: translate(-50%, -50%);
    background-color:#222cccee;
    color:#eee;
    padding:20px 30px;
    border-radius:10px;
    text-align:center;
    font-size:1.5em;
    display:none;
    z-index:10;
  }
</style>
</head>
<body>

<div id="game-container">
   <canvas id="game-canvas"></canvas>
   <div id="game-over"></div>
</div>

<div id="ui">
   <div id="score">Счет: 0</div>
   <button id="start-btn">Старт</button>
   <div id="lives">Жизни: 3</div>
</div>

<script>
// --- Класс для загрузки изображений ---
class ImageLoader {
   constructor() {
      this.images = {};
   }

   load(name, src) {
      return new Promise((res, rej) => {
         const img = new Image();
         img.onload = () => { this.images[name] = img; res(img); };
         img.onerror = () => rej(`Ошибка загрузки изображения ${src}`);
         img.src = src;
      });
   }

   get(name) {
      return this.images[name];
   }
}

// --- Класс змейки ---
class Snake {
   constructor(cellSize, cols, rows) {
      this.cellSize = cellSize; // размер клетки в px
      this.cols = cols; // количество клеток по горизонтали
      this.rows = rows; // количество клеток по вертикали
      this.reset();
   }

   reset() {
      // Змейка начинается в центре поля длиной в одну клетку
      this.body = [{ x: Math.floor(this.cols /2), y : Math.floor(this.rows /2)}];
      this.direction = { x :0, y :0 }; // движение пока не началось
      this.nextDirection = { x :0, y :0 }; // для плавного изменения направления
      this.growAmount =0; // сколько клеток добавить после еды
   }

   setDirection(x,y) {
      // Запрещаем разворот на противоположное направление
      if ((x === -this.direction.x && y === -this.direction.y) || (x === this.direction.x && y === this.direction.y)) return;

      this.nextDirection = {x,y};
   }

   update() {
      if (this.nextDirection.x !==0 || this.nextDirection.y !==0) {
         this.direction = {...this.nextDirection};
      }
      
      if (this.direction.x ===0 && this.direction.y ===0) return;

      const head = {...this.body[0]};
      head.x += this.direction.x;
      head.y += this.direction.y;

      // Добавляем новую голову
      this.body.unshift(head);

      if (this.growAmount >0) {
         this.growAmount--;
         // не удаляем хвост - змейка растет
      } else {
         // удаляем хвост - змейка движется без роста
         this.body.pop();
      }
   }

   grow() {
     this.growAmount++;
   }

   getHead() {
     return this.body[0];
   }

   collideWithSelf() {
     const head = this.getHead();
     for(let i=1;i<this.body.length;i++) {
       if(this.body[i].x === head.x && this.body[i].y === head.y) return true;
     }
     return false;
   }

   collideWithWalls() {
     const head = this.getHead();
     return head.x <0 || head.x >=this.cols || head.y <0 || head.y >=this.rows ;
   }

}

// --- Класс еды и бонусов ---
class ItemManager{
 constructor(cols, rows){
   this.cols=cols; 
   this.rows=rows;

   // Объекты будут храниться в массиве с типом и координатами
   // Типы 'food', 'bomb', 'heart'
   
   this.items=[];
 }

 spawnItem(type, excludePositions){
   
   let pos;

   do{
     pos={
       x : Math.floor(Math.random()*this.cols),
       y : Math.floor(Math.random()*this.rows)
     };
     // Проверяем чтобы позиция не совпадала с исключениями (змейка и другие предметы)
     
     var conflict= excludePositions.some(p=>p.x===pos.x && p.y===pos.y);
     
     var conflictItems= this.items.some(i=>i.x===pos.x && i.y===pos.y);
     
     if(!conflict && !conflictItems) break;

   }while(true);
// Добавляем предмет в массив items
this.items.push({type,x : pos.x,y : pos.y});
}

removeItemAt(x,y){
 for(let i=0;i<this.items.length;i++){
 if(this.items[i].x===x && this.items[i].y===y){
     this.items.splice(i,1);
     return true;}
 }
 return false;}
getItemAt(x,y){
 for(let i=0;i<this.items.length;i++){
 if(this.items[i].x===x && this.items[i].y===y){
     return this.items[i];
 }}
 return null;}
}

// --- Основной класс игры ---
class Game{
 constructor(canvas, scoreEl,livesEl,startBtn, gameOverEl,imgLoader){
    
        // Размеры игрового поля в клетках (будут пересчитываться при ресайзе)
        // Для удобства сделаем квадратное поле с размером ~30 клеток по стороне
        
        this.canvas=canvas;        
        this.ctx=canvas.getContext('2d');
        this.scoreEl=scoreEl;        
        this.livesEl=livesEl;        
        this.startBtn=startBtn;        
        this.gameOverEl=gameOverEl;

        // Загрузчик картинок
        this.imgLoader=imgLoader;

        // Настройки игры:
        // Размер клетки в px будет вычисляться динамически при ресайзе
        
        window.addEventListener('resize', ()=>this.resize());
        
        // Изначальные значения:
        this.score=0;        
        this.lives=3;

        // Флаг запущена ли игра сейчас:
        this.isRunning=false;

        // Тайминг движения змейки (в мс)
        // Для плавного движения мы будем использовать requestAnimationFrame и интерполяцию
        
        // Скорость змейки - клеток в секунду:
        this.speedCellsPerSecond=7;

        // Время между шагами змейки:
        this.stepInterval=null;


// Инициализация игры (создание объектов)
this.resize();

this.snake=new Snake(this.cellSize,this.cols,this.rows);
this.itemManager=new ItemManager(this.cols,this.rows);



// Привязка обработчиков клавиш

window.addEventListener('keydown', e=>{
if(!this.isRunning)return;

// Стрелки и WASD

switch(e.key){
 case 'ArrowUp':
 case 'w':
 case 'W':
 e.preventDefault();
this.snake.setDirection(0,-1);
break;

case 'ArrowDown':
case 's':
case 'S':
e.preventDefault();
this.snake.setDirection(0,1);
break;

case 'ArrowLeft':
case 'a':
case 'A':
e.preventDefault();
this.snake.setDirection(-1,0);
break;

case 'ArrowRight':
case 'd':
case 'D':
e.preventDefault();
this.snake.setDirection(1,0);
break;


}
});


// Кнопка старт

startBtn.addEventListener('click', () => {
  if (this.isRunning) return;

  if (this.lives <= 0) {
    this.score = 0;
    this.lives = 3;
  }

  this.isRunning = true;
  this.snake.reset();
  this.itemManager.items = [];
  
  // Спавним первую еду
  this.itemManager.spawnItem('food', this.snake.body);

  this.updateUI();
  this.gameOverEl.style.display = 'none';

  // Запускаем игровой цикл
  this.lastStepTime = performance.now();
  requestAnimationFrame(this.gameLoop.bind(this));
});

updateUI() {
  this.scoreEl.textContent = `Счет: ${this.score}`;
  this.livesEl.textContent = `Жизни: ${this.lives}`;
}

gameLoop(timestamp) {
  if (!this.isRunning) return;

  const elapsed = timestamp - (this.lastStepTime || timestamp);
  
  if (elapsed > (1000 / this.speedCellsPerSecond)) {
    this.lastStepTime = timestamp;

    // Обновляем змейку
    this.snake.update();

    // Проверяем столкновения
    if (this.snake.collideWithWalls() || this.snake.collideWithSelf()) {
      this.lives--;
      if (this.lives <= 0) {
        this.endGame();
        return;
      } else {
        // Сброс змейки без сброса счета
        this.snake.reset();
      }
      this.updateUI();
    }

    // Проверяем съедание предметов
    const head = this.snake.getHead();
    const item = this.itemManager.getItemAt(head.x, head.y);
    if (item) {
      switch(item.type) {
        case 'food':
          this.score += 10;
          this.snake.grow();
          break;
        case 'bomb':
          this.lives--;
          if (this.lives <=0) {
            this.endGame();
            return;
          }
          break;
        case 'heart':
          this.lives++;
          break;
      }
      // Удаляем съеденный предмет
      this.itemManager.removeItemAt(head.x, head.y);

      // Спавним новую еду или бонусы по логике
      if(item.type === 'food') {
        // Спавним новую еду
        const excludePositions = [...this.snake.body];
        excludePositions.push(...this.itemManager.items);
        this.itemManager.spawnItem('food', excludePositions);
      }

      this.updateUI();
    }

    // Отрисовываем состояние игры
    this.draw();
  }

  requestAnimationFrame(this.gameLoop.bind(this));
}

draw() {
  const ctx = this.ctx;
  
  ctx.clearRect(0,0,this.canvas.width,this.canvas.height);

  // Рисуем змейку
  ctx.fillStyle = '#0f0';
  for(const segment of this.snake.body){
    ctx.fillRect(segment.x * this.cellSize, segment.y * this.cellSize,
                 this.cellSize -1 ,this.cellSize -1);
  }

  // Рисуем предметы
  for(const item of this.itemManager.items){
    switch(item.type){
      case 'food':
        ctx.fillStyle = 'yellow';
        break;
      case 'bomb':
        ctx.fillStyle = 'red';
        break;
      case 'heart':
        ctx.fillStyle = 'pink';
        break;
    }
    ctx.beginPath();
    ctx.arc(item.x * this.cellSize + this.cellSize/2,
            item.y * this.cellSize + this.cellSize/2,
            this.cellSize/2 -2,
            0,
            Math.PI*2);
    ctx.fill();
  }
}

endGame() {
   this.isRunning = false;
   this.gameOverEl.textContent = `Игра окончена! Ваш счет: ${this.score}`;
   this.gameOverEl.style.display = 'block';
   // Можно отключить кнопку старт или изменить ее текст
}